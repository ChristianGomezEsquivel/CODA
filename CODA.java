/* CODA.java */
/* Generated By:JavaCC: Do not edit this line. CODA.java */
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class CODA implements CODAConstants {

    //Variable para error (Bandera de errores)
    static int error = 0;

    //variables para semantica-------------------------------
    String Type="";
    String Valor=""; //variables cache para capturar el par
    String IDenUso="";
    java.util.ArrayList<ParOrd> ParOrdenado = new java.util.ArrayList<ParOrd>(); //Lista de IDs

    //--------------------------------------------------------
    String ruta = "C:/CODA/EjTabla.txt";
    int label = 0;//Etiquetas usadas en Bucle
    String var;
    String CI = ""; //Almacén de Código Intermedio
    int labelB = 0;//Etiquetas usadas en Bucle
    String variable = "";
    String operacion = "";
    String cantidad = "";
    CTDOA codigo_aritmetico = new CTDOA();
    boolean vigilanteId = true;
    EscrituraCI ECI = new EscrituraCI(ruta);//Escritura de Código Intermedio

    //Inicio varibales para Ensamblador-----------------------------------------------------------------------------
    static String Call = "cmd /k start C:/CODA/Ensamble.bat";
    GeneradorObj trans = new GeneradorObj("C:/CODA/CodigoObj.cpp");
    //Fin varibales para Ensamblador-----------------------------------------------------------------------
    int bandf=0;

    public static void main (String args []) throws ParseException{
        CODA analizador = new CODA(System.in);
        System.out.println("-------- CODA ---------\u005cn");
        //analizador.Inicio();
        analizador.Gramatica();
        if(error == 0){
            System.out.println("C\u00f3digo sin errores\u005cn");
            try {
              Runtime.getRuntime().exec(Call);
            }
            catch(java.io.IOException e) {
                e.printStackTrace();
            }
        }
        System.out.println("\u005cnCompilaci\u00f3n finalizada");
    }

// -------------------------- INICIO DE GRAMATICAS ---------------------------------------------------


//---------------------------------- PRINICIPAL ------------------------
  final public void Gramatica() throws ParseException {
    Inicio();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ENTERO:
      case FLOAT:
      case CADENA:
      case INPUT:
      case OUTPUT:
      case CondIF:
      case RWhile:
      case RFor:
      case ALFABETO:
      case ID_VARIABLE:
      case ERRORES:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      Sentencias();
    }
    Fin();
  }

  final public void Sentencias() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ENTERO:
    case FLOAT:
    case CADENA:
    case ID_VARIABLE:{
      Declaraciones();
      break;
      }
    case CondIF:
    case ERRORES:{
      If();
      break;
      }
    case INPUT:
    case OUTPUT:
    case ALFABETO:{
      Acciones();
      break;
      }
    case RWhile:
    case RFor:{
      Ciclos();
      break;
      }
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//-------------------------- INICIO Y FINAL -----------------
  final public void Inicio() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INICIO:{
      jj_consume_token(INICIO);
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba la palabra inicio"); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[2] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 la palabra 'inicio'");error=1;
    }
  }

  final public void Fin() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FIN:{
      jj_consume_token(FIN);
trans.end_to_CPlus();
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba la palabra fin");error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[3] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 la palabra 'fin'");error=1;
    }
  }

//------------------------- DECLARACIONES Y ASIGNACIONES -----------------------
  final public void Declaraciones() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ENTERO:{
      jj_consume_token(ENTERO);
Type = "ent";
        trans.EscribirCod("int ");
      IdentificadorDec();
Valor = token.image + "";
        IDenUso = Valor;
        validacionIDs();
        DeclaracionesEnteros();
      break;
      }
    case CADENA:{
      jj_consume_token(CADENA);
Type = "cad";
        trans.EscribirCod("string ");
      IdentificadorDec();
Valor = token.image + "";
        validacionIDs();
        DeclaracionesCadenas();
      break;
      }
    case FLOAT:{
      jj_consume_token(FLOAT);
Type = "flot";
        trans.EscribirCod("float ");
      IdentificadorDec();
Valor = token.image + "";
        validacionIDs();
        DeclaracionesFlotantes();
      break;
      }
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
Valor = token.image + "";
        String v=remfc(token.image);
        trans.EscribirCod(v);
        validacionAsig();
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//-------------------------------------------------------- FLOTANTES ---------------------------------------------------------------
  final public void DeclaracionesFlotantes() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASIGNAR:{
      jj_consume_token(ASIGNAR);
trans.EscribirCod("= ");
        DeclaracionesFlotantes2();
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        error=1;
        DeclaracionesFlotantesTerminales();
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        error=1;
        DeclaracionesFlotantesTerminales();
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un valor num\u00e9rico");
        error=1;
        DeclaracionesFlotantesTerminales();
      break;
      }
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
Valor = token.image+"";
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        error=1;
        validacionFlot();
        DeclaracionesFlotantesTerminales();
      break;
      }
    case SUMA:{
      jj_consume_token(SUMA);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        trans.EscribirCod("+ ");
        DeclaracionesFlotantes2();
      break;
      }
    case MULTIPLICACION:{
      jj_consume_token(MULTIPLICACION);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        trans.EscribirCod("* ");
        DeclaracionesFlotantes2();
      break;
      }
    case RESTA:{
      jj_consume_token(RESTA);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        trans.EscribirCod("- ");
        DeclaracionesFlotantes2();
      break;
      }
    case DIVISION:{
      jj_consume_token(DIVISION);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        trans.EscribirCod("/ ");
        DeclaracionesFlotantes2();
      break;
      }
    case RESIDUO:{
      jj_consume_token(RESIDUO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        trans.EscribirCod("% ");
        DeclaracionesFlotantes2();
      break;
      }
    case PUNTO:{
      jj_consume_token(PUNTO);
trans.EscribirCod(";\u005cn");
      break;
      }
    default:
      jj_la1[5] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 no se ingres\u00f3 el '.'");error=1;
    }
  }

  final public void DeclaracionesFlotantes2() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
trans.EscribirCod(token.image + " ");
        DeclaracionesFlotantesTerminales();
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
trans.EscribirCod(token.image + " ");
        DeclaracionesFlotantesTerminales();
      break;
      }
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
Valor = token.image+"";
        String v=remfc(token.image);
        trans.EscribirCod(v);
        validacionFlot();
        DeclaracionesFlotantesTerminales();
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un valor num\u00e9rico");error=1;
        DeclaracionesFlotantesTerminales();
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un valor num\u00e9rico");error=1;
        DeclaracionesFlotantesTerminales();
      break;
      }
    default:
      jj_la1[6] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        error=1;
        DeclaracionesFlotantesTerminales();
    }
  }

  final public void DeclaracionesFlotantesTerminales() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PUNTO:{
      jj_consume_token(PUNTO);
trans.EscribirCod(";\u005cn");
      break;
      }
    case SUMA:{
      jj_consume_token(SUMA);
trans.EscribirCod("+ ");
        DeclaracionesFlotantes2();
      break;
      }
    case MULTIPLICACION:{
      jj_consume_token(MULTIPLICACION);
trans.EscribirCod("* ");
        DeclaracionesFlotantes2();
      break;
      }
    case RESTA:{
      jj_consume_token(RESTA);
trans.EscribirCod("- ");
        DeclaracionesFlotantes2();
      break;
      }
    case DIVISION:{
      jj_consume_token(DIVISION);
trans.EscribirCod("/ ");
        DeclaracionesFlotantes2();
      break;
      }
    case RESIDUO:{
      jj_consume_token(RESIDUO);
trans.EscribirCod("% ");
        DeclaracionesFlotantes2();
      break;
      }
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
Valor = token.image+"";
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador, intenta con +,-,*");
        validacionFlot();
        DeclaracionesFlotantesTerminales();
        error = 1;
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador, intenta con +,-,*");
        error=1;
        DeclaracionesFlotantesTerminales();
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador, intenta con +,-,*");
        error=1;
        DeclaracionesFlotantesTerminales();
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador, intenta con +,-,*");
        System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un valor num\u00e9rico");
        error=1;
        DeclaracionesFlotantesTerminales();
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador, intenta con +,-,*");
        System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un valor num\u00e9rico");
        error=1;
        DeclaracionesFlotantesTerminales();
      break;
      }
    default:
      jj_la1[7] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el '.'");error=1;
    }
  }

//------------------------------------------------ FIN FLOTANTES ---------------------------------------------------------------

//-------------------------------------------------- CADENAS ----------------------------------------------------------
  final public void DeclaracionesCadenas() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASIGNAR:{
      jj_consume_token(ASIGNAR);
trans.EscribirCod("= ");
        ECI.EscribirD(" "+token.image);
        DeclaracionesCadenas2();
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se esperaba el s\u00edmbolo de asignacion '='");error=1;
        ECI.EscribirD(" "+token.image);
        DeclaracionesCadenasTerminales();
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se esperaba el s\u00edmbolo de asignacion '='");error=1;
        System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba una cadena");
        DeclaracionesCadenasTerminales();
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se esperaba el s\u00edmbolo de asignacion '='");error=1;
        System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba una cadena");
        DeclaracionesCadenasTerminales();
      break;
      }
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
Valor = token.image+"";
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se esperaba el s\u00edmbolo de asignacion '='");
        error=1;
        validacionCad();
        DeclaracionesCadenasTerminales();
      break;
      }
    case SUMA:{
      jj_consume_token(SUMA);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        trans.EscribirCod("+ ");
        DeclaracionesCadenas2();
      break;
      }
    case MULTIPLICACION:{
      jj_consume_token(MULTIPLICACION);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba +");
        trans.EscribirCod("* ");
        DeclaracionesCadenas2();
      break;
      }
    case RESTA:{
      jj_consume_token(RESTA);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba +");
        trans.EscribirCod("- ");
        DeclaracionesCadenas2();
      break;
      }
    case DIVISION:{
      jj_consume_token(DIVISION);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba +");
        trans.EscribirCod("/ ");
        DeclaracionesCadenas2();
      break;
      }
    case RESIDUO:{
      jj_consume_token(RESIDUO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba +");
        trans.EscribirCod("% ");
        DeclaracionesCadenas2();
      break;
      }
    case PUNTO:{
      jj_consume_token(PUNTO);
trans.EscribirCod(";\u005cn");
      break;
      }
    default:
      jj_la1[8] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el '.'");error=1;
    }
  }

  final public void DeclaracionesCadenas2() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CADENAS:{
      jj_consume_token(CADENAS);
trans.EscribirCod(token.image+" ");
        ECI.EscribirD(" "+token.image);
        DeclaracionesCadenasTerminales();
      break;
      }
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
Valor = token.image+"";
        String v=remfc(token.image);
        trans.EscribirCod(v);
        validacionCad();
        DeclaracionesCadenasTerminales();
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba una cadena");error=1;
        DeclaracionesCadenasTerminales();
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba una cadena");error=1;
        DeclaracionesCadenasTerminales();
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba una cadena");error=1;
        DeclaracionesCadenasTerminales();
      break;
      }
    default:
      jj_la1[9] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        error=1;
        DeclaracionesCadenasTerminales();
    }
  }

  final public void DeclaracionesCadenasTerminales() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PUNTO:{
      jj_consume_token(PUNTO);
trans.EscribirCod(";\u005cn");
      break;
      }
    case SUMA:{
      jj_consume_token(SUMA);
ECI.EscribirD(" "+token.image);
        trans.EscribirCod("+ ");
        DeclaracionesCadenas2();
      break;
      }
    case MULTIPLICACION:{
      jj_consume_token(MULTIPLICACION);
System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba +");
        error=1;
        DeclaracionesCadenas2();
      break;
      }
    case RESTA:{
      jj_consume_token(RESTA);
System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba +");
        error=1;
        DeclaracionesCadenas2();
      break;
      }
    case DIVISION:{
      jj_consume_token(DIVISION);
System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba +");
        error=1;
        DeclaracionesCadenas2();
      break;
      }
    case RESIDUO:{
      jj_consume_token(RESIDUO);
System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba +");
        error=1;
        DeclaracionesCadenas2();
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador, intenta con +");
        System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba una cadena");
        error=1;
        DeclaracionesCadenasTerminales();
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador, intenta con +");
        System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba una cadena");
        error=1;
        DeclaracionesCadenasTerminales();
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador, intenta con +");
        error=1;
        DeclaracionesCadenasTerminales();
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador, intenta con +");
        System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba una cadena");error=1;
        error = 1;
        DeclaracionesCadenasTerminales();
      break;
      }
    default:
      jj_la1[10] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el '.'");error=1;
    }
  }

//------------------------------------------- FIN CADENAS --------------------------------------------------

//---------------------------------------ENTEROS ---------------------------------------------------------
  final public void DeclaracionesEnteros() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASIGNAR:{
      jj_consume_token(ASIGNAR);
trans.EscribirCod("= ");
        codigo_aritmetico = new CTDOA();
        DeclaracionesEnteros2();
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se esperaba un el s\u00edmbolo de asignacion =");error=1;
        DeclaracionesEnterosTerminales();
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se esperaba un el s\u00edmbolo de asignacion =");error=1;
       System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un n\u00famero entero");
       DeclaracionesEnterosTerminales();
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se esperaba un el s\u00edmbolo de asignacion =");error=1;
       System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un n\u00famero entero");
        DeclaracionesEnterosTerminales();
      break;
      }
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se esperaba un el s\u00edmbolo de asignacion =");error=1;
        Valor = token.image+"";
        validacionEnt();
        DeclaracionesEnterosTerminales();
      break;
      }
    case SUMA:{
      jj_consume_token(SUMA);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        error = 1;
        trans.EscribirCod("+ ");
        DeclaracionesEnteros2();
      break;
      }
    case MULTIPLICACION:{
      jj_consume_token(MULTIPLICACION);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        trans.EscribirCod("* ");
        DeclaracionesEnteros2();
      break;
      }
    case RESTA:{
      jj_consume_token(RESTA);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        trans.EscribirCod("- ");
        DeclaracionesEnteros2();
      break;
      }
    case DIVISION:{
      jj_consume_token(DIVISION);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        trans.EscribirCod("/ ");
        DeclaracionesEnteros2();
      break;
      }
    case RESIDUO:{
      jj_consume_token(RESIDUO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        trans.EscribirCod("% ");
        DeclaracionesEnteros2();
      break;
      }
    case PUNTO:{
      jj_consume_token(PUNTO);
trans.EscribirCod(";\u005cn");
      break;
      }
    default:
      jj_la1[11] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el '.'");error=1;
    }
  }

  final public void DeclaracionesEnteros2() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
codigo_aritmetico.add(token.image+"");
        var = ""+token.image;
        trans.EscribirCod(token.image);
        DeclaracionesEnterosTerminales();
      break;
      }
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
Valor = token.image+"";
        codigo_aritmetico.add(token.image+"");
        var = ""+token.image;
        validacionEnt();
        String v=remfc(token.image);
        trans.EscribirCod(v);
        DeclaracionesEnterosTerminales();
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un n\u00famero entero");error=1;
        DeclaracionesEnterosTerminales();
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un n\u00famero entero");error=1;
        DeclaracionesEnterosTerminales();
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un n\u00famero entero");error=1;
        DeclaracionesEnterosTerminales();
      break;
      }
    default:
      jj_la1[12] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        error=1;
        DeclaracionesEnterosTerminales();
    }
  }

  final public void DeclaracionesEnterosTerminales() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PUNTO:{
      jj_consume_token(PUNTO);
if(vigilanteId){
            if(codigo_aritmetico.longitud()>=3){
                CI += codigo_aritmetico.generarCodigo();
                CI += "      " + "     " + codigo_aritmetico.nombreVariable + "            " + Valor + "\u005cn\u005cn";
                ECI.EscribirOA(CI);
                codigo_aritmetico = new CTDOA();
                CI = "";
            }else{
                ECI.EscribirOA( "   =       " + var + "             "+ Valor + "\u005cn\u005cn");//Al ser correcta la declaración se genera el código intermedio
            }
        }else vigilanteId = true;

        codigo_aritmetico = new CTDOA();
        trans.EscribirCod(";");
      break;
      }
    case SUMA:{
      jj_consume_token(SUMA);
codigo_aritmetico.add(token.image);
        trans.EscribirCod(" + ");
        DeclaracionesEnteros2();
      break;
      }
    case MULTIPLICACION:{
      jj_consume_token(MULTIPLICACION);
codigo_aritmetico.add(token.image);
        trans.EscribirCod(" * ");
        DeclaracionesEnteros2();
      break;
      }
    case RESTA:{
      jj_consume_token(RESTA);
codigo_aritmetico.add(token.image);
        trans.EscribirCod(" - ");
        DeclaracionesEnteros2();
      break;
      }
    case DIVISION:{
      jj_consume_token(DIVISION);
codigo_aritmetico.add(token.image);
        trans.EscribirCod(" / ");
        DeclaracionesEnteros2();
      break;
      }
    case RESIDUO:{
      jj_consume_token(RESIDUO);
codigo_aritmetico.add(token.image);
        trans.EscribirCod("% ");
        DeclaracionesEnteros2();
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador, intenta con +,-,*");
        error = 1;
        DeclaracionesEnterosTerminales();
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador, intenta con +,-,*");
        System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un n\u00famero entero");
        error=1;
        DeclaracionesEnterosTerminales();
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador, intenta con +,-,*");
        System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un n\u00famero entero");
        error=1;
        DeclaracionesEnterosTerminales();
      break;
      }
    default:
      jj_la1[13] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el '.'");error=1;
    }
  }

//-------------------------------------- FIN ENTEROS ------------------------------------------------------------

//------------------------------------------------------ FIN DE DECLARACIONES Y ASIGNACIONES --------------------------------------------------------


// ------------------------------- INICIO DE MAS GRAMATICAS ------------------------------------------------------------

//----------------- IN Y OUT ------------------------------------------------------
  final public 
void Acciones() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INPUT:
    case ALFABETO:
    case ERRORES:{
      Entrada();
      break;
      }
    case OUTPUT:{
      Salida();
      break;
      }
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//GRAMATICA PARA EL IN = ingresar(@a).
  final public 
void Entrada() throws ParseException {
    En();
ECI.EscribirB("\u005cnL"+(++label)+": "+token.image+" ");
    AParentIO();
    Identificador();
ECI.EscribirB(token.image+" ");
    CParentIO();
    Punto();
  }

//GRAMATICA PARA EL OUT = mostrar(@a) o mostrar("hola")
  final public 
void Salida() throws ParseException {
    Sal();
ECI.EscribirB("\u005cnL"+(++label)+": "+token.image+" ");
    AParentIO();
    Cadenas();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SUMA:{
      Concatenar();
      break;
      }
    default:
      jj_la1[15] = jj_gen;
      ;
    }
ECI.EscribirB(token.image+" ");
    CParentIO();
    Punto();
  }

  final public void Concatenar() throws ParseException {
    jj_consume_token(SUMA);
trans.EscribirCod("<<");
    Cadenas();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SUMA:{
      Concatenar();
      break;
      }
    default:
      jj_la1[16] = jj_gen;
      ;
    }
  }

//----------------------------------------------------- CONDICIONALES Y CICLOS -----------------------------------

//CONDICION UTILIZADA PARA CICLOS Y CONDICIONALES @a < @b por ejemplo
  final public void Condic() throws ParseException {
    Identificador();
ECI.EscribirB(token.image+" ");
        validarTipo(); //SE DIRIGE PARA VER QUE TIPO DE DATO ES Y PODER REALIZAR LA COMPARACION ADECUADA

  }

  void validarTipo() throws ParseException {String tipo = "";
    boolean v = false;
    for(ParOrd e : ParOrdenado){
        if(e.id.equals(Valor)){
            v = true;
            if(e.tipo == "cad"){
                CondCad();//SI ES DE TIPO CADENA SE DIRIGE A CONDICION CADENA
            }
            if(e.tipo == "ent" || e.tipo == "flot"){
                CondNum();// SI ES FLOT O ENT SE DIRIGE A CONDICION NUM
            }
            break;
        }
    }
    if(v==false){
        error=1;
        CondDefault();//EN CASO DE QUE NO EXISTE LA VARIABLE SE HACE UN RECORRIDO SIN RESTRICCIONES POR EL TIPO DE DATO
    }
  }

  final public void CondDefault() throws ParseException {
    OperadoresDef();
    Identificador();
  }

  final public void OperadoresDef() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CompMAYOR:{
      jj_consume_token(CompMAYOR);
ECI.EscribirB("> ");
      break;
      }
    case CompMENOR:{
      jj_consume_token(CompMENOR);
ECI.EscribirB("< ");
      break;
      }
    case CompIGUAL:{
      jj_consume_token(CompIGUAL);
ECI.EscribirB("== ");
      break;
      }
    case CompDIFERENTE:{
      jj_consume_token(CompDIFERENTE);
ECI.EscribirB("!= ");
      break;
      }
    case CompMAY_IGUAL:{
      jj_consume_token(CompMAY_IGUAL);
ECI.EscribirB(">= ");
      break;
      }
    case CompMEN_IGUAL:{
      jj_consume_token(CompMEN_IGUAL);
ECI.EscribirB("<= ");
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '" + token.image +"', se esperaba 'myq', 'mnq', 'myiq', 'mniq', 'dif', 'igu'"); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[17] = jj_gen;
{System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un operador l\u00f3gico");} error=1;
    }
  }

  final public void CondCad() throws ParseException {
    OperadoresCad();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
Valor = token.image+"";
        String v=remfc(token.image);
        trans.EscribirCod(v);
        ECI.EscribirB(token.image+" ");
        validacionCad();
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un identificador");error=1;
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un identificador");error=1;
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 "+ token.image +", se esperaba un identificador");error=1;
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 "+ token.image +", se esperaba un identificador");error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[18] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el identificador");error=1;
    }
  }

  final public void CondNum() throws ParseException {
    OperadoresNum();
    Identificador();
ECI.EscribirB(token.image+" ");
        validacionNum();
  }

//----------- CONDICIONALES -------------------------------------------------------

// GRAMATICA PARA EL IF = si(@a myq @b){}
  final public void If() throws ParseException {
    Esi();
ECI.EscribirB("\u005cn"+"L"+(++label)+": if ");
    AParent();
    Condic();
    CParent();
ECI.EscribirB(" goto L"+(label+1)+"\u005cn");
    ALlave();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ENTERO:
      case FLOAT:
      case CADENA:
      case INPUT:
      case OUTPUT:
      case CondIF:
      case RWhile:
      case RFor:
      case ALFABETO:
      case ID_VARIABLE:
      case ERRORES:{
        ;
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        break label_2;
      }
      Sentencias();
    }
    CLlave();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CondIF_ELSE:{
      jj_consume_token(CondIF_ELSE);
ECI.EscribirB(" \u005cnL"+(++label)+": If Else goto L"+(label+1)+"\u005cn");trans.EscribirCod("else");Sino();
      break;
      }
    default:
      jj_la1[20] = jj_gen;
      ;
    }
  }

//EN CASO DE PONER SINO ENTRA EL NUEVO METODO sino{} Despues de cerrar las llaves puede haber mas sinos
  final public void Sino() throws ParseException, ParseException {
    ALlave();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ENTERO:
      case FLOAT:
      case CADENA:
      case INPUT:
      case OUTPUT:
      case CondIF:
      case RWhile:
      case RFor:
      case ALFABETO:
      case ID_VARIABLE:
      case ERRORES:{
        ;
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        break label_3;
      }
      Sentencias();
    }
    CLlave();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CondIF_ELSE:{
      jj_consume_token(CondIF_ELSE);
ECI.EscribirB(" \u005cnElse goto L"+(label+1));trans.EscribirCod("else");Sino();
      break;
      }
    default:
      jj_la1[22] = jj_gen;
      ;
    }
  }

//------------- CICLOS --------------------------------------------------------
  final public 
void Ciclos() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case RFor:{
      Parar();

      break;
      }
    case RWhile:{
      Mientras();
      break;
      }
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//GRAMATICA PARA EL CICLO FOR = parar[ent @z = 3 o @z = 3][@z mnq @b][dism @b:2]{}
  final public void Parar() throws ParseException {
    jj_consume_token(RFor);
trans.EscribirCod("for");
    CondF();
    ALlave();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ENTERO:
      case FLOAT:
      case CADENA:
      case INPUT:
      case OUTPUT:
      case CondIF:
      case RWhile:
      case RFor:
      case ALFABETO:
      case ID_VARIABLE:
      case ERRORES:{
        ;
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        break label_4;
      }
      Sentencias();
    }
    CLlave();
ECI.EscribirB(" \u005cnL"+(++label)+" "+variable+" = "+variable+operacion+cantidad);
        ECI.EscribirB(" \u005cngoto L"+labelB);
        ECI.EscribirB(" \u005cnElse goto L"+(label+1));
  }

  final public void CondF() throws ParseException {
    ACorch();
trans.EscribirCod("(");
    AsignFor();
    CCorch();
    ACorch();
ECI.EscribirB("\u005cn"+"L"+(++label)+": if ");labelB=label;
    Condic();
    CCorch();
ECI.EscribirB(" goto L"+(label+1));trans.EscribirCod(";");
    ACorch();
    Aumentar();
    CCorch();
  }

//GRAMATICA PARA AUMENTAR O DISMINUIR aum @b : 3
  final public void Aumentar() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case AUMENTAR:{
      jj_consume_token(AUMENTAR);
operacion="+";bandf=1;
      break;
      }
    case DISMINUIR:{
      jj_consume_token(DISMINUIR);
operacion="-";bandf=2;
      break;
      }
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    IdentificadorEntero();
variable=token.image+"";
    Puntos();
trans.EscribirCod(opfor(bandf));
    Entero();
cantidad=token.image+"";trans.EscribirCod(")");
  }

  public String opfor(int opcion) throws ParseException {if(opcion==1){
        return "+=";
    }if(opcion==2){
        return "-=";
    }
    return "";
  }

  final public void IdentificadorEntero() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
Valor = token.image+"";
        validacionEnt();
        String v=remfc(token.image);
        trans.EscribirCod(v);
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un identificador");error=1;
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un identificador");error=1;
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 "+ token.image +", se esperaba un identificador");error=1;
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 "+ token.image +", se esperaba un identificador");error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[26] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el identificador");error=1;
    }
  }

//GRAMATICA PARA EL WHILE = mientras[@b igu @c]{}
  final public 
void Mientras() throws ParseException {
    jj_consume_token(RWhile);
ECI.EscribirB("L"+(++label)+": If ");trans.EscribirCod("while ");labelB=label;
    CondW();
    ALlave();
ECI.EscribirB(" goto L"+(label+1));
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ENTERO:
      case FLOAT:
      case CADENA:
      case INPUT:
      case OUTPUT:
      case CondIF:
      case RWhile:
      case RFor:
      case ALFABETO:
      case ID_VARIABLE:
      case ERRORES:{
        ;
        break;
        }
      default:
        jj_la1[27] = jj_gen;
        break label_5;
      }
      Sentencias();
    }
ECI.EscribirB(" \u005cngoto L"+labelB+"\u005cnElse goto L"+(label+1)+"\u005cn");
    CLlave();
  }

//GRAMATICA DE LA CONDICION PARA EL WHILE = @b mnq @a
  final public 
void CondW() throws ParseException {
    ACorch();
trans.EscribirCod("(");
    Condic();
    CCorch();
trans.EscribirCod(")");
  }

//---------------------------------------- FIN DE GRAMATICAS --------------------------------------------------------

//-------------------------------------  BLOQUE DE ERRORES SINTACTICOS ---------------------------------------------

// A PARTIR DE AQUI SON METODOS UTILIZADOS PARA COMPROBAR ERRORES EN LAS DISTINTAS GRAMATICAS
// POR EJEMPLO A LA HORA DE ABRIR LLAVES SE COMPRUEBA QUE SEAN LLAVES O QUE EXISTAN ASI CON LOS DEMAS EN SUS RESPECTIVAS GRAMATICAS
// ESTO SE HIZO PARA AHORRAR CODIGO Y NO HACER LAS VALIDACIONES CADA VEZ QUE SE OCUPEN DICHOS ELEMENTOS
  final public 
void AsignFor() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
Valor = token.image+"";
        String v=remfc(token.image);
        trans.EscribirCod(v);
        AsignacionCiclo();
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un identificador");
        error=1;
        DeclaracionesEnteros();
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un identificador");
        error=1;
        DeclaracionesEnteros();
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 "+ token.image +", se esperaba un identificador");
        error=1;
        DeclaracionesEnteros();
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 "+ token.image +", se esperaba un identificador");
        error=1;
        DeclaracionesEnteros();
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[28] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el identificador");error=1;
    }
  }

  final public void Cadenas() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CADENAS:{
      jj_consume_token(CADENAS);
trans.EscribirCod(token.image+" ");
      break;
      }
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
Valor = token.image+"";
        String a=remfc(token.image);
        trans.EscribirCod(a);
        ExistenciaIDs();
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba una cadena o un identificador"); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[29] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el dato a mostrar"); error=1;
    }
  }

  final public void Entero() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
trans.EscribirCod(token.image);
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un n\u00famero entero"); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[30] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el n\u00famero entero"); error=1;
    }
  }

  final public void Puntos() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DPUNTOS:{
      jj_consume_token(DPUNTOS);
      break;
      }
    case PUNTO:{
      jj_consume_token(PUNTO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba ':'"); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[31] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 ':'"); error=1;
    }
  }

  final public void ACorch() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CorchA:{
      jj_consume_token(CorchA);
      break;
      }
    case ParentA:
    case LlaveA:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ParentA:{
        jj_consume_token(ParentA);
        break;
        }
      case LlaveA:{
        jj_consume_token(LlaveA);
        break;
        }
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba '['"); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[33] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 '['"); error=1;
    }
  }

  final public void CCorch() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CorchC:{
      jj_consume_token(CorchC);
      break;
      }
    case ParentC:
    case LlaveC:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ParentC:{
        jj_consume_token(ParentC);
        break;
        }
      case LlaveC:{
        jj_consume_token(LlaveC);
        break;
        }
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba ']'"); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[35] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 ']'"); error=1;
    }
  }

  final public void Esi() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CondIF:{
      jj_consume_token(CondIF);
trans.EscribirCod("if ");
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ALlave() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LlaveA:{
      jj_consume_token(LlaveA);
trans.EscribirCod("{ \u005cn");
      break;
      }
    case CorchA:{
      jj_consume_token(CorchA);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba '{'"); error=1;
      break;
      }
    case ParentA:{
      jj_consume_token(ParentA);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba '{'"); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[37] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 '{'"); error=1;
    }
  }

  final public void CLlave() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LlaveC:{
      jj_consume_token(LlaveC);
trans.EscribirCod("} \u005cn");
      break;
      }
    case CorchC:{
      jj_consume_token(CorchC);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba '}'"); error=1;
      break;
      }
    case ParentC:{
      jj_consume_token(ParentC);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba '}'"); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[38] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 '}'"); error=1;
    }
  }

  final public void En() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INPUT:{
      jj_consume_token(INPUT);
trans.EscribirCod("cin >> ");
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 " + token.image +", se esperaba 'ingresar' "); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Sal() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case OUTPUT:{
      jj_consume_token(OUTPUT);
trans.EscribirCod("cout << ");
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 " + token.image +", se esperaba 'ingresar' "); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void AParentIO() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ParentA:{
      jj_consume_token(ParentA);
      break;
      }
    case CorchA:{
      jj_consume_token(CorchA);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 " + token.image +", se esperaba '(' "); error=1;
      break;
      }
    case LlaveA:{
      jj_consume_token(LlaveA);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 " + token.image +", se esperaba '(' "); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[41] = jj_gen;
{System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 '('");} error=1;
    }
  }

  final public void CParentIO() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ParentC:{
      jj_consume_token(ParentC);
      break;
      }
    case CorchC:{
      jj_consume_token(CorchC);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 " + token.image +", se esperaba ')'"); error=1;
      break;
      }
    case LlaveC:{
      jj_consume_token(LlaveC);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 " + token.image +", se esperaba ')' "); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[42] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 ')'"); error=1;
    }
  }

  final public void AParent() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ParentA:{
      jj_consume_token(ParentA);
trans.EscribirCod("( ");
      break;
      }
    case CorchA:{
      jj_consume_token(CorchA);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 " + token.image +", se esperaba '(' "); error=1;
      break;
      }
    case LlaveA:{
      jj_consume_token(LlaveA);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 " + token.image +", se esperaba '(' "); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[43] = jj_gen;
{System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 '('");} error=1;
    }
  }

  final public void CParent() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ParentC:{
      jj_consume_token(ParentC);
trans.EscribirCod(") ");
      break;
      }
    case CorchC:{
      jj_consume_token(CorchC);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 " + token.image +", se esperaba ')'"); error=1;
      break;
      }
    case LlaveC:{
      jj_consume_token(LlaveC);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 " + token.image +", se esperaba ')' "); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[44] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 ')'"); error=1;
    }
  }

  final public void Punto() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PUNTO:{
      jj_consume_token(PUNTO);
trans.EscribirCod(";\u005cn");
      break;
      }
    case DPUNTOS:{
      jj_consume_token(DPUNTOS);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 " + token.image +", se esperaba '.'"); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[45] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el '.'"); error=1;
    }
  }

  final public void Identificador() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
Valor = token.image+"";
        String a=remfc(token.image);
        trans.EscribirCod(a);
        ExistenciaIDs();
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un identificador");error=1;
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un identificador");error=1;
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 "+ token.image +", se esperaba un identificador");error=1;
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 "+ token.image +", se esperaba un identificador");error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[46] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el identificador");error=1;
    }
  }

  final public void IdentificadorDec() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
String v=remfc(token.image);
        trans.EscribirCod(v);
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un identificador");error=1;
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un identificador");error=1;
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 "+ token.image +", se esperaba un identificador");error=1;
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 "+ token.image +", se esperaba un identificador");error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[47] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el identificador");error=1;
    }
  }

//---------------------------------------- FIN DE ERRORES SINTACTICOS --------------------------------------------------------

//--------------------------------------- BLOQUE DE ERRORES LEXICOS --------------------------------------------

//COMPRUEBA QUE LO QUE SE INGRESO NO PERTENEZCA A LA LISTA DE VALORES NO PERMITIDOS
  final public 
void LEX() throws ParseException {
    jj_consume_token(ERRORES);
System.out.println("Error l\u00e9xico: en la L\u00ednea: "+ token.beginLine + " Columna: "+ token.beginColumn + " el s\u00edmbolo ("+token.image+") no es reconocido"); error=1;
  }

//---------------------------------------- FIN DE BLOQUE DE ERRORES LEXICOS ----------------------------------------------

// --------------------------- ERRORES SEMANTICOS -----------------------------------------
  final public void OperadoresCad() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CompMAYOR:{
      jj_consume_token(CompMAYOR);
ECI.EscribirB("> "); System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" el tipo de comparaci\u00f3n no es compatible con el tipo de dato, intenta con ==,!=");error=1;
      break;
      }
    case CompMENOR:{
      jj_consume_token(CompMENOR);
ECI.EscribirB("< ");System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" el tipo de comparaci\u00f3n no es compatible con el tipo de dato, intenta con ==,!=");error=1;
      break;
      }
    case CompIGUAL:{
      jj_consume_token(CompIGUAL);
ECI.EscribirB("== ");
      break;
      }
    case CompDIFERENTE:{
      jj_consume_token(CompDIFERENTE);
ECI.EscribirB("!= ");
      break;
      }
    case CompMAY_IGUAL:{
      jj_consume_token(CompMAY_IGUAL);
ECI.EscribirB(">= ");System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" el tipo de comparaci\u00f3n no es compatible con el tipo de dato, intenta con ==,!=");error=1;
      break;
      }
    case CompMEN_IGUAL:{
      jj_consume_token(CompMEN_IGUAL);
ECI.EscribirB("<= ");System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" el tipo de comparaci\u00f3n no es compatible con el tipo de dato, intenta con ==,!=");error=1;
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '" + token.image +"', se esperaba 'myq', 'mnq', 'myiq', 'mniq', 'dif', 'igu'"); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[48] = jj_gen;
{System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un operador l\u00f3gico");} error=1;
    }
  }

  final public void OperadoresNum() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CompMAYOR:{
      jj_consume_token(CompMAYOR);
ECI.EscribirB("> ");trans.EscribirCod(" > ");
      break;
      }
    case CompMENOR:{
      jj_consume_token(CompMENOR);
ECI.EscribirB("< ");trans.EscribirCod(" < ");
      break;
      }
    case CompIGUAL:{
      jj_consume_token(CompIGUAL);
ECI.EscribirB("== ");trans.EscribirCod(" == ");
      break;
      }
    case CompDIFERENTE:{
      jj_consume_token(CompDIFERENTE);
ECI.EscribirB("!= ");trans.EscribirCod(" != ");
      break;
      }
    case CompMAY_IGUAL:{
      jj_consume_token(CompMAY_IGUAL);
ECI.EscribirB(">= ");trans.EscribirCod(" >= ");
      break;
      }
    case CompMEN_IGUAL:{
      jj_consume_token(CompMEN_IGUAL);
ECI.EscribirB("<= ");trans.EscribirCod(" <= ");
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '" + token.image +"', se esperaba 'myq', 'mnq', 'myiq', 'mniq', 'dif', 'igu'"); error=1;
      break;
      }
    case ERRORES:{
      LEX();
      break;
      }
    default:
      jj_la1[49] = jj_gen;
{System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un operador l\u00f3gico");} error=1;
    }
  }

  public void ingresoIDs() throws ParseException {//almacenamiento de identificadores y su tipo
    ParOrdenado.add(new ParOrd(Type, Valor));
    ECI.EscribirD("\u005cnL"+(++label)+": "+Type + "   " + Valor );
  }

  public void validacionIDs() throws ParseException {//validacion de que no existe otra variable con el mismo nombre declarada
    boolean v = false;
    for(ParOrd e : ParOrdenado){
        if(e.id.equals(Valor)){
            v  = true;
            break;
        }
    }
    if(v==true){
        System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" la variable: "+Valor+" ya ha sido declarada");
        error = 1;
    } else ingresoIDs();
  }

  public void ExistenciaIDs() throws ParseException {//validacion de que las variables hayan sido declaradas
    boolean v = false;
    for(ParOrd e : ParOrdenado){
        if(e.id.equals(Valor)){
            v = true;
            break;
        }
    }
    if(!v){
        System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" la variable: "+Valor+" no ha sido declarada");
        error = 1;
    }
  }

  public String remfc(String str) throws ParseException {if(str==null||str.length()==0){
        return str;
    }
    return str.substring(1);
  }

  public void validacionAsig() throws ParseException {String tipo = "";
    boolean v = false;
    for(ParOrd e : ParOrdenado){
        if(e.id.equals(Valor)){
            v = true;
            if(e.tipo == "cad"){
                DeclaracionesCadenas();
            }
            if(e.tipo == "ent"){
                DeclaracionesEnteros();
            }
            if(e.tipo == "flot"){
                DeclaracionesFlotantes();
            }
            break;
        }
    }
    if(v==false){
        System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" la variable: "+Valor+" no ha sido declarada");
        error=1;
        DERROR();
    }
  }

  final public void DERROR() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASIGNAR:{
      jj_consume_token(ASIGNAR);
DE();
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        error=1;
        DET();
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        error=1;
        DET();
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        error=1;
        DET();
      break;
      }
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
Valor = token.image+"";
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        error=1;
        ExistenciaIDs();
        DET();
      break;
      }
    case SUMA:{
      jj_consume_token(SUMA);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        DE();
      break;
      }
    case MULTIPLICACION:{
      jj_consume_token(MULTIPLICACION);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        DE();
      break;
      }
    case RESTA:{
      jj_consume_token(RESTA);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        DE();
      break;
      }
    case DIVISION:{
      jj_consume_token(DIVISION);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        DE();
      break;
      }
    case RESIDUO:{
      jj_consume_token(RESIDUO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el s\u00edmbolo de asignacion '='");
        System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato, intenta con una cadena o un operando");
        DE();
      break;
      }
    case PUNTO:{
      jj_consume_token(PUNTO);
      break;
      }
    default:
      jj_la1[50] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 no se ingres\u00f3 el '.'");error=1;
    }
  }

  final public void DE() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
DET();
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
DET();
      break;
      }
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
Valor = token.image+"";
        ExistenciaIDs();
        DET();
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
DET();
      break;
      }
    case ALFABETO:{
      jj_consume_token(ALFABETO);
System.out.println("Error sem\u00e1ntico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " se ingres\u00f3 '"+ token.image +"', se esperaba un valor num\u00e9rico,cadena o variable");error=1;
        DET();
      break;
      }
    default:
      jj_la1[51] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 un dato");
        error=1;
       DET();
    }
  }

  final public void DET() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PUNTO:{
      jj_consume_token(PUNTO);
      break;
      }
    case SUMA:{
      jj_consume_token(SUMA);
DE();
      break;
      }
    case MULTIPLICACION:{
      jj_consume_token(MULTIPLICACION);
DE();
      break;
      }
    case RESTA:{
      jj_consume_token(RESTA);
DE();
      break;
      }
    case DIVISION:{
      jj_consume_token(DIVISION);
DE();
      break;
      }
    case RESIDUO:{
      jj_consume_token(RESIDUO);
DE();
      break;
      }
    case NUM_ENTERO:{
      jj_consume_token(NUM_ENTERO);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador");
        error=1;
        DET();
      break;
      }
    case NUM_FLOTANTE:{
      jj_consume_token(NUM_FLOTANTE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador");
        error=1;
        DET();
      break;
      }
    case CADENAS:{
      jj_consume_token(CADENAS);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador, intenta con +,-,*");
        error=1;
        DET();
      break;
      }
    case ID_VARIABLE:{
      jj_consume_token(ID_VARIABLE);
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el operador, intenta con +,-,*");
        Valor = token.image+"";
        ExistenciaIDs();
        DET();
      break;
      }
    default:
      jj_la1[52] = jj_gen;
System.out.println("Error sint\u00e1ctico: en la L\u00ednea: "+ token.beginLine +" Columna: "+ token.beginColumn + " no se ingres\u00f3 el '.'");error=1;
    }
  }

  public void validacionNum() throws ParseException {String tipo = "";
    boolean v = false;
    for(ParOrd e : ParOrdenado){
        if(e.id.equals(Valor)){
            v = true;
            if(e.tipo == "cad"){
                System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" la variable: "+Valor+" no es de tipo num\u00e9rico");
                error = 1;
            }
            break;
        }
    }
    if(v==false){
        error = 1;
    }
  }

  public void validacionEnt() throws ParseException {String tipo = "";
    boolean v = false;
    for(ParOrd e : ParOrdenado){
        if(e.id.equals(Valor)){
            v = true;
            if(e.tipo != "ent"){
                System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" la variable: "+Valor+" no es de tipo entero");
                error = 1;
            }
            break;
        }
    }
    if(v==false){
        System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" la variable: "+Valor+" no ha sido declarada");
        error = 1;
    }
  }

  public void validacionFlot() throws ParseException {String tipo = "";
    boolean v = false;
    for(ParOrd e : ParOrdenado){
        if(e.id.equals(Valor)){
            v = true;
            if(e.tipo != "flot"){
                System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" la variable: "+Valor+" no es de tipo num\u00e9rico");
                error = 1;
            }
            break;
        }
    }
    if(v==false){
        System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" la variable: "+Valor+" no ha sido declarada");
        error = 1;
    }
  }

  public void validacionCad() throws ParseException {String tipo = "";
    boolean v = false;
    for(ParOrd e : ParOrdenado){
        if(e.id.equals(Valor)){
            v = true;
            if(e.tipo != "cad"){
                System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" la variable: "+Valor+" no es de tipo cadena");
                error = 1;
            }
            break;
        }
    }
    if(v==false){
        System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" la variable: "+Valor+" no ha sido declarada");
        error = 1;
    }
  }

  public void AsignacionCiclo() throws ParseException {String tipo = "";
    boolean v = false;
    for(ParOrd e : ParOrdenado){
        if(e.id.equals(Valor)){
            v = true;
            if(e.tipo == "cad"){
                System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" la variable: "+Valor+" no es de tipo num\u00e9rico");
                DeclaracionesCadenas();
            }
            if(e.tipo == "ent"){
                DeclaracionesEnteros();
            }
            if(e.tipo == "flot"){
                DeclaracionesFlotantes();
            }
            break;
        }
    }
    if(v==false){
        System.out.println("Error sem\u00e1ntico en la L\u00ednea : "+token.beginLine+" Columna: "+token.beginColumn+" la variable: "+ Valor +" no ha sido declarada");
        DERROR();
    }
  }

  /** Generated Token Manager. */
  public CODATokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[53];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xdf80,0xdf80,0x20,0x40,0x380,0x1f0000,0x0,0x1f0000,0x1f0000,0x0,0x1f0000,0x1f0000,0x0,0x1f0000,0xc00,0x10000,0x10000,0x3f000000,0x0,0xdf80,0x2000,0xdf80,0x2000,0xc000,0xdf80,0x0,0x0,0xdf80,0x0,0x0,0x0,0x0,0x40000000,0x40000000,0x80000000,0x80000000,0x1000,0x40000000,0x80000000,0x400,0x800,0x40000000,0x80000000,0x40000000,0x80000000,0x0,0x0,0x0,0x3f000000,0x3f000000,0x1f0000,0x0,0x1f0000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x8600,0x8600,0x8200,0x8200,0x400,0x7490,0x7600,0x7680,0x7490,0x7600,0x7280,0x7490,0x7600,0x7080,0x8200,0x0,0x0,0x8200,0xf600,0x8600,0x0,0x8600,0x0,0x0,0x8600,0x60,0xf600,0x8600,0xf600,0xc600,0xb000,0x8180,0x4,0x8005,0x8,0x800a,0x8000,0x8005,0x800a,0x8200,0x8200,0x8005,0x800a,0x8005,0x800a,0x8180,0xf600,0xf600,0x8200,0x8200,0x7490,0x7600,0x7480,};
   }

  /** Constructor with InputStream. */
  public CODA(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public CODA(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CODATokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public CODA(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new CODATokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public CODA(CODATokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(CODATokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[48];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 53; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 48; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}

class ParOrd{ //int i

    String tipo, id;

    public ParOrd(String tipo, String id){//
        this.tipo = tipo;
        this.id = id;
    }
}

class CTDOA {//CÓDIGO de TRES DIRECCIONES para OPERACIONES ARITMÉTICAS

    private java.util.ArrayList<String> list;
    private String codigo="",//codigo de 3 direcciones
            v1="", v2="", op="";
    private int no_var=0; String nombreVariable = "T"; //genera la variable temporal
    private int r1,r2,r3;//posiciones de la lista las cuales se modifican
    private int defecto = 1;//posicion de la lista donde se pone a evaluar
    private boolean prioridad = false; //true para prioridad aritmeta nivel 1, fakse para nivel 2
    private boolean listaRecorrida = false;

    public CTDOA(){
        list = new java.util.ArrayList<String>();
    }
    //version 1
    /*
    public void add(String s){
        this.list.add(s);
    }
    */
    //version 2
    public void add(String s) {
        String s0 = "";
        boolean in = true;
        int l = list.size();
        int i = (l > 0) ? (l - 1) : 0;
        l = 0;
        for (String e : list) {//se obtiene el ultimo dato
            if (l == i) s0 = e;
            l++;
        }
        switch (s0) {
            case "1":
                if (s.equals("*")) {
                    //System.out.println("quitar");                    
                    in = false;
                }
                break;
            case "/":
            case "*":
                if (s.equals("1")) {
                    //System.out.println("quitar");                    
                in = false;
                }
                break;
        }

        if (in) {
            this.list.add(s);
        } else {
            list.set(i, "r0");
            list.remove("r0");
        }
    }

    public String generarCodigo(){

        while(!listaRecorrida){
            nivel1(defecto);
            if(prioridad){
                generarVariable();
                codigo += "   "+op  + "       " + v1 + "     " + v2+ "       " + nombreVariable+"\u005cn";
                list.set(r1, "r");
                list.set(r2, "r1");
                list.set(r3, nombreVariable);
                list.remove("r");
                list.remove("r1");

                prioridad=false;
            }
        }

        if(list.size() >= 3)listaRecorrida = false;
        else listaRecorrida = true;

        while(!listaRecorrida){
            nivel2();
            generarVariable();
            codigo += "   "+op  + "       " + v1 + "     " + v2+ "       " + nombreVariable+"\u005cn";
            list.set(0, "r");
            list.set(1, "r1");
            list.set(2, nombreVariable);
            list.remove("r");
            list.remove("r1");
        }
        return this.codigo;
    }
    private void nivel1(int i){//para depurar de operaciones nivel 1(*,/,%)
        int j =1;
        int k =1;
        boolean t = false;

        for(String e : list){
            if(j >= i){
                if( k == 1) v1 = e;
                else if (k == 2){
                    if(!e.equals("+") && !e.equals("-")){
                         op = e;
                         r3=j;
                         r2=j-1;
                         r1 = r2-1;
                         prioridad = true;
                    }else defecto = j+1;
                }
                else if (k == 3) {
                    if (prioridad)v2 = e;
                    t = true;
                }
                k++;
            }
            if (t) break;
            j++;
        }
        if(j == list.size()) listaRecorrida = true;
    }
    private void nivel2(){
        int k = 1;
        for(String e : list){
            if(k == 1) v1 = e;
            if(k == 2) op = e;
            if(k == 3) {
                v2 = e;
                break;
            }
            k++;
        }
        if(k == list.size()) listaRecorrida = true;
    }

    private String generarVariable(){
        nombreVariable="T"+(no_var++);
        return nombreVariable;
    }
    public int longitud() {
        return list.size();
    }
}

class GeneradorObj {
    private java.io.File f;

    public GeneradorObj(String ruta){
        f = new java.io.File(ruta);
        CleanCPP();
        EscribirCod(
            "#include <stdio.h>\u005cn"+
            "#include <iostream>\u005cn"+
            "#include <string>\u005cn"+
            "#include <cstring>\u005cn"+
            "#include <locale.h>\u005cn"+
            "using namespace std;\u005cn"+
            "int main(){\u005cn"+
            "setlocale(LC_ALL,\u005c"Spanish\u005c");\u005cn"
        );

    }

    public static void main(String[] args){
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                GeneradorObj pe = new GeneradorObj("C:/CODACodigoObj.cpp");
                pe.EscribirCod("cout << \u005c"prueba transcrita\u005c";\u005cn");
                pe.end_to_CPlus();
            }
        });
    }

    public void EscribirCod(String s){//Transcribe el codigo
//Escritura
        try {

            java.io.FileWriter w = new java.io.FileWriter(f , true);

            java.io.BufferedWriter bw = new java.io.BufferedWriter(w);

            java.io.PrintWriter wr = new java.io.PrintWriter(bw);
            wr.write(s);//escribimos en el archivo

            //wr.append("\n"); //concatenamos en el archivo sin borrar lo existente

            //ahora cerramos los flujos de canales de datos, al cerrarlos el archivo quedará guardado con información escrita
            //de no hacerlo no se escribirá nada en el archivo
            wr.close();
            bw.close();
        } catch (java.io.IOException e) {
            e.printStackTrace();
            System.out.println("no se pudo escribir");
        }
    }

    private void CleanCPP(){
        //Escritura
        try {

            java.io.FileWriter w = new java.io.FileWriter(f , false);

            java.io.BufferedWriter bw = new java.io.BufferedWriter(w);

            java.io.PrintWriter wr = new java.io.PrintWriter(bw);

            wr.write("");//Escribimos en el archivo.

            //wr.append("\n"); //Concatenamos en el archivo sin borrar lo existente.

            //Ahora cerramos los flujos de canales de datos, al cerrarlos el archivo quedará guardado con información escrita.
            //de no hacerlo no se escribirá nada en el archivo.
            wr.close();
            bw.close();
        } catch (java.io.IOException e) {
            e.printStackTrace();
            System.out.println("No se puedo limpiar");
        }
    }

    public void end_to_CPlus(){
        EscribirCod("system(\u005c"pause\u005c");\u005cnreturn 0;\u005cn}");
    }
}

class EscrituraCI {

    private File f;

    public EscrituraCI(String ruta) {
        f = new File(ruta);
        limpiarTxt();
    }
    private void limpiarTxt(){
        //Escritura
        try {

            FileWriter w = new FileWriter(f , false);

            BufferedWriter bw = new BufferedWriter(w);

            PrintWriter wr = new PrintWriter(bw);

            wr.write("");//Escribimos en el archivo.

            //wr.append("\n"); //Concatenamos en el archivo sin borrar lo existente.

            //Ahora cerramos los flujos de canales de datos, al cerrarlos el archivo quedará guardado con información escrita.
            //de no hacerlo no se escribirá nada en el archivo.
            wr.close();
            bw.close();
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("No se pudo escribir");
        }
    }

    public void EscribirOA(String s){//Escribe Operaciones Aritméticas
        //Escritura
        try {

            FileWriter w = new FileWriter(f , true);

            BufferedWriter bw = new BufferedWriter(w);

            PrintWriter wr = new PrintWriter(bw);
            wr.write("\u005cn"+"operador  " + "arg1  " + "arg2  " + "Resultado   \u005cn");
            wr.write(s);//Escribimos en el archivo.

            //wr.append("\n"); //Concatenamos en el archivo sin borrar lo existente.

            //Ahora cerramos los flujos de canales de datos, al cerrarlos el archivo quedará guardado con información escrita.
            //de no hacerlo no se escribirá nada en el archivo.
            wr.close();
            bw.close();
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("No se pudo escribir");
        }
    }

    public void EscribirD(String s){//Escribe Declaraciones
        try {

            FileWriter w = new FileWriter(f , true);

            BufferedWriter bw = new BufferedWriter(w);

            PrintWriter wr = new PrintWriter(bw);
            wr.write(s);//Escribimos en el archivo.

            //wr.append("\n"); //Concatenamos en el archivo sin borrar lo existente.

            //Ahora cerramos los flujos de canales de datos, al cerrarlos el archivo quedará guardado con información escrita.
            //de no hacerlo no se escribirá nada en el archivo.
            wr.close();
            bw.close();
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("No se pudo escribir");
        }
    }

    public void EscribirB(String s){

        try {

            FileWriter w = new FileWriter(f , true);

            BufferedWriter bw = new BufferedWriter(w);

            PrintWriter wr = new PrintWriter(bw);
            wr.write(s);//Escribimos en el archivo.
            //wr.append("\n"); //Concatenamos en el archivo sin borrar lo existente.

            //Ahora cerramos los flujos de canales de datos, al cerrarlos el archivo quedará guardado con información escrita.
            //de no hacerlo no se escribirá nada en el archivo.
            wr.close();
            bw.close();
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("No se pudo escribir");
        }
    }

}
